# ============================================================================
# HIERARCHICAL WORKFLOW CONFIGURATION
# ============================================================================
#
# OVERVIEW
# --------
# The hierarchical topology implements a classic lead-worker pattern where a
# coordinating agent (lead) manages and distributes work to a pool of worker
# agents. This creates a tree-like structure of delegation with clear lines
# of responsibility.
#
# WHEN TO USE HIERARCHICAL
# ------------------------
# - Medium to large teams (3-10+ agents) where coordination overhead justifies
#   a dedicated lead
# - Projects requiring strategic decomposition of complex goals
# - When you need clear accountability and progress monitoring
# - Situations where some agents have specialized skills (use `needed_tags`)
# - When work items vary in granularity (coarse strategic vs fine atomic tasks)
#
# NOT RECOMMENDED FOR
# -------------------
# - Solo work (use workflow-solo.yaml)
# - Fully independent parallel tasks with no coordination needs (use swarm)
# - Strictly sequential specialist handoffs (use relay)
# - Very small teams (2-3 agents) where overhead exceeds benefit
#
# LEAD/WORKER DYNAMICS
# --------------------
# Lead Agent:
#   - Connects with `tags: [lead, coordinator]`
#   - Receives or claims high-level goals
#   - Decomposes complex tasks into atomic subtasks using `create_tree()`
#   - Pushes tasks to workers via `update(assignee="worker-id")`
#   - Monitors progress with `list_agents()` and `list_tasks(status="working")`
#   - Handles escalations, blockers, and reassignments
#   - Sets priorities and adjusts plans dynamically
#
# Worker Agents:
#   - Connect with `tags: [worker]` (plus any specialty tags)
#   - Pull available work with `list_tasks(ready=true, agent="worker-id")`
#   - Can also receive pushed assignments (status="assigned")
#   - Focus on atomic, well-defined subtasks (1-2 at a time)
#   - Report progress via `thinking()` and `attach()` for notes
#   - Complete tasks with `update(status="completed")`
#
# DELEGATION PATTERNS
# -------------------
# 1. Decomposition: Lead breaks down a feature into subtasks
#    ```yaml
#    create_tree:
#      tree:
#        title: "Implement User Auth"
#        children:
#          - title: "Design auth schema"
#            points: 2
#          - title: "Implement login endpoint"
#            points: 3
#          - title: "Write auth tests"
#            points: 2
#      sibling_type: "follows"  # Sequential execution
#    ```
#
# 2. Push Assignment: Lead assigns task to specific worker
#    ```yaml
#    update:
#      task: "auth-tests-task"
#      assignee: "worker-security"  # Worker with security expertise
#    ```
#
# 3. Pull Coordination: Workers claim from available pool
#    ```yaml
#    list_tasks:
#      ready: true
#      agent: "worker-3"  # Filters by worker's tags
#    claim:
#      worker_id: "worker-3"
#      task: "task-id"
#    ```
#
# 4. Contains Hierarchy: Parent tasks track subtask completion
#    - Default `parent_child: contains` dependency
#    - Parent auto-tracks child progress
#    - Useful for rollup metrics and completion tracking
#
# COORDINATION FLOW
# -----------------
#                   +-----------+
#                   |   Lead    |
#                   | (decompose|
#                   |  & assign)|
#                   +-----+-----+
#                         |
#          +--------------+--------------+
#          |              |              |
#          v              v              v
#     +--------+    +--------+    +--------+
#     |Worker 1|    |Worker 2|    |Worker 3|
#     | (pull) |    | (push) |    | (pull) |
#     +--------+    +--------+    +--------+
#
# KEY CONFIGURATION POINTS
# ------------------------
# - `roles.lead.max_claims`: Higher limit (5) for tracking multiple work streams
# - `roles.worker.max_claims`: Lower limit (2) to encourage focus
# - `roles.lead.can_assign`: Only leads can push tasks to workers
# - `hierarchical.lead_settings.require_estimates`: Enforce estimation discipline
# - `hierarchical.worker_settings.require_file_marks`: Prevent edit conflicts
# - `hierarchical.thresholds`: Alerts for stale tasks and overloaded workers
#
# ============================================================================

# Lead agent delegates to worker pool with mixed push/pull coordination

name: hierarchical
description: Lead agent delegates to worker pool

# Inherit base settings, override as needed
settings:
  initial_state: pending
  disconnect_state: pending
  blocking_states: [pending, assigned, working]
  unknown_phase: warn

# Role definitions
roles:
  lead:
    description: Coordinates work, decomposes tasks, monitors progress
    tags: [lead, coordinator]
    max_claims: 5           # Can hold multiple top-level tasks
    can_assign: true        # Can push tasks to workers
    can_create_subtasks: true

  worker:
    description: Claims and completes atomic subtasks
    tags: [worker]
    max_claims: 2           # Focus on 1-2 tasks at a time
    can_assign: false
    can_create_subtasks: false

# States with role-specific prompts
states:
  pending:
    exits: [assigned, working, cancelled]
    timed: false

  assigned:
    exits: [working, pending, cancelled]
    timed: false
    prompts:
      enter: |
        A task has been assigned to you by the lead. Review and claim when ready.

  working:
    exits: [completed, failed, pending]
    timed: true
    prompts:
      enter: |
        You are now actively working on this task. Keep your thinking updated regularly using the `thinking` tool to show progress and allow coordination with other agents.

        ## Valid Next States

        From `{{current_status}}` you can transition to:
        {{valid_exits}}

        Use `update(status="completed")` when done, `update(status="failed")` if blocked, or `update(status="pending")` to release without completing.

        ## Phase

        Current phase: {{current_phase}}

        Valid phases: {{valid_phases}}

        Set a phase with `update(phase="implement")` to categorize the type of work you're doing.
      exit: |
        Before leaving working state:
        - [ ] Unmark any files you marked
        - [ ] Attach results or notes
        - [ ] Log costs with `log_metrics()`

  completed:
    exits: [pending]
    timed: false
    prompts:
      enter: |
        Task completed. Results should be attached.

  failed:
    exits: [pending]
    timed: false
    prompts:
      enter: |
        Task failed. Please document:
        - What was attempted
        - What blocked progress
        - Suggested next steps

  cancelled:
    exits: []
    timed: false

# Phase definitions
phases:
  explore:
    prompts:
      exit: |
        Capture exploration findings before moving on.
        Attach discoveries to parent task for sibling agents.

  plan:
    prompts:
      enter: |
        Planning phase. For leads: decompose work into subtasks.

  implement:
    prompts:
      enter: |
        Implementation phase. Mark files before editing.

  review:
    prompts:
      enter: |
        ## Code Review Checklist
        - [ ] Tests pass
        - [ ] No new warnings
        - [ ] Documentation updated

  test:
    prompts:
      enter: |
        Testing phase. Verify the implementation works correctly.

  security:
    prompts:
      enter: |
        ## Security Review
        - [ ] Input validation
        - [ ] Auth/authz checks
        - [ ] No secrets in code

  # Phases without prompts
  deliver: {}
  triage: {}
  diagnose: {}
  design: {}
  doc: {}
  integrate: {}
  deploy: {}
  monitor: {}
  optimize: {}

# State+Phase specific prompts
combos:
  working+implement:
    enter: |
      You're implementing. Focus on:
      - Follow existing patterns
      - Write tests alongside code
      - Keep commits atomic

  working+review:
    enter: |
      Code review in progress:
      - Check for correctness
      - Look for edge cases
      - Verify test coverage

  working+plan:
    enter: |
      Planning phase active. Focus on:
      - Breaking down complex work into atomic subtasks
      - Identifying dependencies between subtasks
      - Estimating effort for each subtask

# Role-specific prompts
role_prompts:
  lead:
    # Decomposition prompts
    decomposition: |
      ## Task Decomposition Guidelines

      As the lead, break down high-level tasks into atomic subtasks:

      1. **Analyze the goal**: Understand what needs to be accomplished
      2. **Identify components**: What distinct pieces of work are needed?
      3. **Define boundaries**: Each subtask should be:
         - Atomic (completable in one work session)
         - Independent (minimal dependencies on other subtasks)
         - Testable (clear success criteria)
      4. **Create subtasks**: Use `create_tree` with `contains` dependencies
      5. **Set estimates**: Add `time_estimate_ms` and `points` to each subtask

      Example decomposition:
      ```
      create_tree(tree={
        "title": "Implement feature X",
        "children": [
          {"title": "Design API interface", "points": 2},
          {"title": "Implement core logic", "points": 3},
          {"title": "Write unit tests", "points": 2},
          {"title": "Update documentation", "points": 1}
        ]
      }, sibling_type="follows")
      ```

    # Assignment prompts
    assignment: |
      ## Task Assignment Guidelines

      Push high-level tasks to workers when:
      - A worker has the required expertise (check tags)
      - The task is well-defined and ready for work
      - Dependencies are satisfied

      To assign a task:
      ```
      update(task="task-id", assignee="worker-id")
      ```

      This sets the task status to `assigned` and notifies the worker.

      Prefer pushing to:
      - Workers with matching `needed_tags` requirements
      - Workers with lower current claim counts
      - Workers who have context from related tasks

    # Monitoring prompts
    monitoring: |
      ## Progress Monitoring Guidelines

      As lead, regularly monitor worker progress:

      1. **Check active workers**: `list_agents()` to see who's working on what
      2. **Review task status**: `list_tasks(status="working")` for active work
      3. **Identify blockers**: Look for `failed` or stalled tasks
      4. **Track metrics**: `project_history()` for velocity insights

      Warning signs to watch:
      - Tasks in `working` state too long (check `claimed_at`)
      - Workers with many claimed tasks (overloaded)
      - Subtasks blocked on dependencies
      - Failed tasks that need reassignment

      When issues arise:
      - Check worker thinking: Are they stuck?
      - Offer guidance via task attachments
      - Reassign if worker is unavailable: `update(task="id", assignee="other-worker", force=true)`

  worker:
    # Claiming prompts
    claiming: |
      ## Task Claiming Guidelines

      As a worker, find and claim available subtasks:

      1. **Find ready tasks**: `list_tasks(ready=true, agent="your-id")`
         - This filters for tasks you're qualified to claim
         - Tasks are sorted by priority
      2. **Check dependencies**: Ensure blocking tasks are complete
      3. **Claim the task**: `claim(task="task-id", worker_id="your-id")`
      4. **Mark files**: Before editing, mark files you'll touch

      Best practices:
      - Claim one task at a time unless parallel work is possible
      - Check task attachments for context from the lead
      - Verify you understand the success criteria before starting

    # Completing prompts
    completing: |
      ## Task Completion Guidelines

      Before marking a task complete:

      1. **Verify success criteria**: Does the work meet requirements?
      2. **Run tests**: Ensure nothing is broken
      3. **Attach results**: Document what was done
         ```
         attach(task="task-id", type="result", content="Description of work done")
         ```
      4. **Unmark files**: Release any marked files
      5. **Log metrics**: Record time and cost
         ```
         log_metrics(task="task-id", agent="your-id", cost_usd=0.05)
         ```
      6. **Complete the task**:
         ```
         update(task="task-id", status="completed", reason="Work completed successfully")
         ```

    # Reporting prompts
    reporting: |
      ## Reporting Guidelines

      Keep the lead informed of your progress:

      1. **Regular thinking updates**: Use `thinking(thought="...")` frequently
         - What you're currently doing
         - Any blockers or questions
         - Estimated time remaining

      2. **Attach progress notes**: For longer tasks
         ```
         attach(task="task-id", type="progress", content="50% complete, working on X")
         ```

      3. **Report blockers immediately**: If you can't proceed
         ```
         update(task="task-id", status="failed", reason="Blocked because...")
         ```

      4. **Ask questions via attachments**:
         ```
         attach(task="task-id", type="question", content="Need clarification on...")
         ```

# Hierarchical-specific settings
hierarchical:
  # Lead behavior
  lead_settings:
    auto_decompose: false       # Lead manually decomposes (not auto)
    min_subtask_points: 1       # Minimum story points for subtask
    max_subtask_points: 5       # Maximum story points for subtask
    require_estimates: true     # Subtasks must have estimates

  # Worker behavior
  worker_settings:
    max_concurrent_claims: 2    # Workers can claim up to 2 tasks
    auto_claim_priority: true   # Prefer higher priority tasks
    require_file_marks: true    # Must mark files before editing

  # Dependency defaults
  dependency_defaults:
    parent_child: contains      # Parent contains children
    sibling: null               # Siblings are parallel by default
    milestone: blocks           # Milestones block dependent work

  # Metrics thresholds
  thresholds:
    stale_task_hours: 4         # Warn if task claimed > 4 hours
    max_worker_claims: 3        # Alert if worker has > 3 claims
    velocity_window_days: 7     # Calculate velocity over 7 days
