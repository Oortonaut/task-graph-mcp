# HIERARCHICAL WORKFLOW - Lead agent delegates to worker pool
# Use for: medium-large teams (3-10+), strategic decomposition, specialized skills
# Coordination: lead decomposes & assigns, workers pull or receive tasks

name: hierarchical
description: Lead agent delegates to worker pool

settings:
  initial_state: pending
  disconnect_state: pending
  blocking_states: [pending, assigned, working]
  unknown_phase: warn

# Role definitions
roles:
  lead:
    description: Coordinates work, decomposes tasks, monitors progress
    tags: [lead, coordinator]
    max_claims: 5
    can_assign: true
    can_create_subtasks: true

  worker:
    description: Claims and completes atomic subtasks
    tags: [worker]
    max_claims: 2
    can_assign: false
    can_create_subtasks: false

# States with prompts
states:
  pending:
    exits: [assigned, working, cancelled]
    timed: false

  assigned:
    exits: [working, pending, cancelled]
    timed: false
    prompts:
      enter: Task assigned by lead. Review and claim when ready.

  working:
    exits: [completed, failed, pending, consult]
    timed: true
    prompts:
      enter: |
        **Hierarchical working.** `thinking()` regularly for heartbeat + visibility.

        - Never revert unfamiliar changes: check `mark_updates()` / `list_marks()` first
        - `list_marks()` before editing to check conflicts
        - 5+ files? Decompose into subtasks first
        - `mark_updates()` every 30-60s during long ops
        - Stale workers (5+ min no heartbeat) get evicted
        - **Git lock**: `claim(task="_lock:git-commit")` -> commit -> release via `update(task="_lock:git-commit", status="pending")`

        Transitions: {{valid_exits}}
        Phase: {{current_phase}} | Valid: {{valid_phases}}

      exit: "Unmark files, attach results, `log_metrics()`."

  completed:
    exits: [pending]
    timed: false
    prompts:
      enter: Task completed. Results should be attached.

  failed:
    exits: [pending]
    timed: false
    prompts:
      enter: |
        Task failed. **Recovery procedure:**

        1. **Preserve work:** `attach(type="error", content="...")` with what was attempted and what blocked
        2. **Clean up resources:**
           - `unmark_file()` all held files -- dangling marks block other workers
           - Release any held locks: `update(task="_lock:git-commit", status="pending")` if you hold the git lock
        3. **Classify the failure:**
           - *Transient* (network, timeout, flaky test): set back to `pending` for retry
           - *Dependency blocked*: `link(type="blocks", from="blocking-task")` and document in error attachment
           - *Needs human decision*: move to `consult` instead with clear question
           - *Permanent* (wrong approach, impossible constraint): stay `failed`, document why
        4. **Notify lead:** `thinking(thought="FAILED: <one-line reason>")` so lead can reassign or decompose differently
        5. **Suggest next steps:** attach concrete recommendations (retry, reassign, decompose smaller, escalate)

  consult:
    exits: [working, pending, cancelled]
    timed: false
    prompts:
      enter: |
        **Paused for human review.** Before pausing:
        1. `unmark_file()` all held files -- you may be paused for a long time
        2. Release any locks: `update(task="_lock:git-commit", status="pending")` if held
        3. `attach(type="note", content="...")` explaining:
           - What specific decision or input is needed
           - What options you see and their trade-offs
           - What you have completed so far
        4. A human (or lead) must transition this back to `working` or `pending`

  cancelled:
    exits: []
    timed: false

# Phase definitions
phases:
  explore:
    prompts:
      enter: "**Explore.** Read code, docs, related tasks. Identify constraints. Attach findings for lead/siblings."
      exit: "Attach exploration findings to parent task."

  plan:
    prompts:
      enter: "**Plan.** Decompose via `create_tree()`. Set `needed_tags`, estimates, and dependencies."
      exit: "Ensure subtasks created with descriptions, deps set, estimates assigned."

  design:
    prompts:
      enter: "**Design.** Document approach, interfaces, key decisions, and rejected alternatives. Attach as plan note."
      exit: "Ensure design doc attached with rationale."

  implement:
    prompts:
      enter: "**Implement.** `mark_file()` first. Follow codebase patterns. Tests alongside code. Atomic commits."
      exit: "Ensure: compiles, tests pass, commit attached."

  review:
    prompts:
      enter: "**Review.** Tests pass, no warnings, docs updated."
      exit: "Ensure findings documented, blockers escalated, approval attached."

  test:
    prompts:
      enter: "**Test.** Run existing tests, add new ones, cover edge cases and error paths."
      exit: "Ensure test results attached, all passing, edges covered."

  security:
    prompts:
      enter: "**Security.** Input validation, auth/authz, no secrets in code."
      exit: "Ensure findings attached, critical issues escalated."

  triage:
    prompts:
      enter: "**Triage.** Classify (bug/feature/refactor/chore), set priority 0-10, assess scope, route via `update(assignee=...)`."
      exit: "Ensure tags/priority set, description clear, assigned or ready."

  diagnose:
    prompts:
      enter: "**Diagnose.** Reproduce, narrow to module/function, attach findings, create implement subtask."
      exit: "Ensure root cause documented, fix approach outlined."

  doc:
    prompts:
      enter: "**Document.** Update README, API docs, inline comments. Verify examples."
      exit: "Ensure doc changes committed."

  integrate:
    prompts:
      enter: "**Integrate.** Full test suite. Check conflicts via `mark_updates()`. Coordinate with lead on merges."

  deliver:
    prompts:
      enter: "**Deliver.** All tests green, build clean. Version bumps and changelog if applicable."

  deploy:
    prompts:
      enter: "**Deploy.** Release build. Tag if applicable. Monitor initial deployment."

  monitor:
    prompts:
      enter: "**Monitor.** Check errors and performance. Time-box. Attach observations."

  optimize:
    prompts:
      enter: "**Optimize.** Measure baseline, change one thing, re-measure. Keep only measurable improvements."

# State+Phase combos
combos:
  working+implement:
    enter: |
      Implementing. Follow patterns, tests alongside, atomic commits.
      - **3+ files**: search ALL symbols first, mark_file() ALL, plan attachment before coding
      - **Git lock**: `claim(task="_lock:git-commit")` -> commit -> `update(task="_lock:git-commit", status="pending")`

  working+review:
    enter: "Review: correctness, edge cases, test coverage."

  working+plan:
    enter: "Planning: decompose into atomic subtasks, set deps, estimate effort."

  working+explore:
    enter: "Exploring: read code/docs, attach findings. Time-box then move to design/plan."

  working+test:
    enter: "Testing: run suite, add tests, verify edges. Attach results."

  working+triage:
    enter: "Triaging: categorize, prioritize, assess scope. Route or decompose."

  working+diagnose:
    enter: "Diagnosing: reproduce, narrow down, root cause. Attach findings before fix tasks."

  working+security:
    enter: "Security: input validation, auth, secrets, deps. Attach findings. Escalate critical."

  failed+implement:
    enter: |
      Implementation failed. Before leaving:
      - `unmark_file()` all held files and release git lock if held
      - `attach(type="error")` with: files modified, tests that failed, build errors
      - If partially committed: attach the commit hash so the next worker can continue or revert

  failed+test:
    enter: |
      Testing failed. Attach: which tests failed, repro commands, whether this is a test bug or code bug.
      If flaky: note the flaky test so the next attempt can distinguish real failures.

  assigned+implement:
    enter: "Implementation assigned. Read task description and attached context before claiming."

  assigned+review:
    enter: "Review assigned. Read implementation and design context before claiming."

  assigned+test:
    enter: "Test assigned. Check implementation and review notes before claiming."

# Role-specific prompts
role_prompts:
  lead:
    decomposition: |
      Decompose into atomic, independent, testable subtasks via `create_tree()`.
      Set `time_estimate_ms` and `points` on each.

    assignment: |
      Assign via `update(task="id", assignee="worker-id")`.
      Prefer workers with matching tags, lower claim counts, or related context.

    monitoring: |
      Monitor: `list_agents()` for active workers, `list_tasks(status="working")` for active work.
      Watch for long-running tasks, overloaded workers, blocked deps.
      Reassign: `update(task="id", assignee="other-worker", force=true)`.

    failure_handling: |
      **When a worker task fails:**
      1. Read the error attachment to understand the failure class
      2. *Transient failure*: `update(task="id", status="pending")` to re-queue for retry (same or different worker)
      3. *Dependency failure*: check `list_tasks(status="failed")` for cascading failures; fix root cause first
      4. *Scope issue*: decompose the failed task into smaller subtasks via `create_tree()`
      5. *Repeated failure* (same task failed 2+ times): escalate to `consult` with summary of all attempts
      6. **Cascading failure check:** when a task fails, `list_tasks(parent="<parent-id>")` to check
         if sibling tasks should be paused (`update(status="pending")`) to avoid wasted work

  worker:
    claiming: |
      1. `list_tasks(ready=true, agent="your-id")` - find qualified tasks by priority
      2. `claim(task="id", worker_id="your-id")`
      3. `mark_file()` before editing
      4. Never revert unfamiliar changes - check `mark_updates()` first
      Claim one at a time. Check attachments for lead context.

    completing: |
      Before completing:
      1. Verify success criteria met
      2. Run tests
      3. `attach(type="result", content="...")` - document work done
      4. `unmark_file()` - release files
      5. `log_metrics(cost_usd=...)` - record cost
      6. `update(status="completed")`

    reporting: |
      Use `thinking(thought="...")` frequently with status, blockers, ETA.
      Longer tasks: `attach(type="progress", content="...")`.
      Blocked: `update(status="failed", reason="...")`.
      Questions: `attach(type="question", content="...")`.

# Hierarchical-specific settings
hierarchical:
  lead_settings:
    auto_decompose: false
    min_subtask_points: 1
    max_subtask_points: 5
    require_estimates: true

  worker_settings:
    max_concurrent_claims: 2
    auto_claim_priority: true
    require_file_marks: true

  dependency_defaults:
    parent_child: contains
    sibling: null
    milestone: blocks

  thresholds:
    stale_task_hours: 4
    max_worker_claims: 3
    velocity_window_days: 7

# Gates (bidirectional lead-worker communication)
gates:
  status:working:
    - type: "gate/results"
      enforcement: warn
      description: "Attach results for lead visibility"

  status:assigned:
    - type: "gate/spec"
      enforcement: warn
      description: "Lead should provide task specification"

# Attachment types (compact reference)
attachments:
  lead_to_worker:
    context: Essential background info (replaces)
    plan: Decomposition details and approach (markdown, replaces)
    note: Clarifications or additional instructions (appends)
  worker_to_lead:
    result: Structured completion data (JSON, replaces)
    note: Progress updates, questions, observations (appends)
    error: Blockers or failures needing lead attention (appends)
  code_artifacts:
    commit: Git commit hash (appends)
    diff: Code changes for review (appends)
    changelist: Files modified (appends)
  operations:
    log: Chronological work record (appends)
    output: Command/test output (appends)
    meta: Structured metadata (JSON, replaces)
