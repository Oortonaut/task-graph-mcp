# SOLO WORKFLOW - Single agent, coarse-grained tasks, pull coordination
# Use for: individual work, prototyping, personal task management
# Key: explore -> design -> implement -> test -> review phases

name: solo
description: Single agent working alone with coarse-grained, independent tasks

# Override base settings for solo work
settings:
  initial_state: pending
  disconnect_state: pending
  blocking_states: [pending, assigned, working]
  unknown_phase: warn

# Solo-specific state prompts
states:
  pending:
    exits: [working, cancelled]
    timed: false
    prompts:
      enter: |
        Task available. Review and begin when ready.

  # Solo worker skips 'assigned' - directly claims work
  working:
    exits: [completed, failed, pending]
    timed: true
    prompts:
      enter: |
        **Solo working.** Focus deeply; attach notes for context continuity.

        Transitions: {{valid_exits}}
        Phase: {{current_phase}} | Valid: {{valid_phases}}

        - Progress phases via `update(phase="...")`
        - Self-review before completing
        - Attach results for your future self

      exit: |
        Before completing:
        - [ ] Attach summary
        - [ ] Note follow-up work
        - [ ] `log_metrics()`

  completed:
    exits: [pending]
    timed: false
    prompts:
      enter: |
        Done. Results attached? Follow-up tasks needed?

  failed:
    exits: [pending]
    timed: false
    prompts:
      enter: |
        Blocked. Document: attempted, blocker, resources needed. Set `pending` to retry.

  cancelled:
    exits: []
    timed: false

# Phase prompts
phases:
  explore:
    prompts:
      enter: |
        **Explore.** Read code/docs, understand patterns, identify constraints. Attach findings.
      exit: |
        Attach exploration summary before moving on.

  design:
    prompts:
      enter: |
        **Design.** Outline solution, consider alternatives, identify risks.

  implement:
    prompts:
      enter: |
        **Implement.** Follow patterns, write tests, keep commits small, `mark_file` before editing.

  test:
    prompts:
      enter: |
        **Test.** Run existing tests, add new ones, cover edge cases.

  review:
    prompts:
      enter: |
        **Self-review checklist:**
        - [ ] Code matches design?
        - [ ] Edge cases handled?
        - [ ] Tests comprehensive?
        - [ ] Documentation updated?

  doc:
    prompts:
      enter: |
        **Document.** Update README, add comments, API docs, examples as needed.

  security:
    prompts:
      enter: |
        **Security checklist:**
        - [ ] Input validation
        - [ ] Auth/authz
        - [ ] No secrets in code
        - [ ] Dependencies checked

  deliver: {}
  triage: {}
  diagnose: {}
  plan: {}
  integrate: {}
  deploy: {}
  monitor: {}
  optimize: {}

# State+Phase combos
combos:
  working+explore:
    enter: Explore thoroughly. Attach notes as you learn.

  working+implement:
    enter: Execute with full context. Follow patterns, test alongside code, atomic commits.

  working+review:
    enter: Self-review mode. Check bugs, edge cases, test coverage.

# Gates (warn = self-discipline reminders, use force=true with reason to skip)
gates:
  status:working:
    - type: "gate/tests"
      enforcement: warn
      description: "Attach test results or explain why tests don't apply"
    - type: "gate/commit"
      enforcement: warn
      description: "Attach commit hash or note why no commit needed"

# Attachment types (document for future context)
attachments:
  recommended:
    note: Observations, decisions, reasoning (appends)
    plan: Approach and design (markdown, replaces)
    result: Outcome data (JSON, replaces)
    context: Resume state (replaces)
  documentation:
    log: Chronological actions (appends)
    diff: Code changes (appends)
    commit: Git hash reference (appends)
  debugging:
    error: Failures/blockers (appends)
    output: Command output (appends)
  metadata:
    meta: Structured metadata (JSON, replaces)
