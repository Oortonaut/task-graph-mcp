# SOLO WORKFLOW - Single agent, coarse-grained tasks, pull coordination
# Use for: individual work, prototyping, personal task management
# Key: explore -> design -> implement -> test -> review phases

name: solo
description: Single agent working alone with coarse-grained, independent tasks

# Override base settings for solo work
settings:
  initial_state: pending
  disconnect_state: pending
  blocking_states: [pending, assigned, working]
  unknown_phase: warn

# Solo-specific state prompts
states:
  pending:
    exits: [working, cancelled]
    timed: false
    prompts:
      enter: |
        Task available. Review and begin when ready.

  # Solo worker skips 'assigned' - directly claims work
  working:
    exits: [completed, failed, pending, consult]
    timed: true
    prompts:
      enter: |
        **Solo working.** Focus deeply; attach notes for context continuity.

        Transitions: {{valid_exits}}
        Phase: {{current_phase}} | Valid: {{valid_phases}}

        - Progress phases via `update(phase="...")`
        - Self-review before completing
        - Attach results for your future self
        - **Never revert unfamiliar changes**: if you find unexpected modifications in a file, do NOT revert them. Another worker may have made those changes. Use `mark_updates()` or `list_marks()` to check, and coordinate before overwriting
        - **Before editing**: call list_marks() to check if other workers have marked the same files. If conflicts found, coordinate or pick a different task
        - **Estimate scope first**: if a task touches 5+ files or requires broad symbol renaming, decompose into subtasks before starting. Three focused subtasks are better than one sprawling change

        ### Heartbeat
        - Call `thinking(agent=your_id, thought="...")` periodically to maintain heartbeat
        - Stale workers (no heartbeat for 5+ min) get evicted automatically

      exit: |
        Before completing:
        - [ ] Attach summary
        - [ ] Note follow-up work
        - [ ] `log_metrics()`

  completed:
    exits: [pending]
    timed: false
    prompts:
      enter: |
        Done. Results attached? Follow-up tasks needed?

  failed:
    exits: [pending]
    timed: false
    prompts:
      enter: |
        Blocked. Document: attempted, blocker, resources needed. Set `pending` to retry.

  consult:
    exits: [working, pending, cancelled]
    timed: false
    prompts:
      enter: |
        **Paused for human review.** This task requires human input before proceeding.
        Attach a note explaining what decision or review is needed.
        A human must transition this task back to `working` or `pending`.

  cancelled:
    exits: []
    timed: false

# Phase prompts
phases:
  explore:
    prompts:
      enter: |
        **Explore.** Read code/docs, understand patterns, identify constraints. Attach findings.
      exit: |
        Attach exploration summary before moving on.

  design:
    prompts:
      enter: |
        **Design.** Outline solution, consider alternatives, identify risks.

  implement:
    prompts:
      enter: |
        **Implement.** Follow patterns, write tests, keep commits small, `mark_file` before editing.

  test:
    prompts:
      enter: |
        **Test.** Run existing tests, add new ones, cover edge cases.

  review:
    prompts:
      enter: |
        **Self-review checklist:**
        - [ ] Code matches design?
        - [ ] Edge cases handled?
        - [ ] Tests comprehensive?
        - [ ] Documentation updated?

  doc:
    prompts:
      enter: |
        **Document.** Update README, add comments, API docs, examples as needed.

  security:
    prompts:
      enter: |
        **Security checklist:**
        - [ ] Input validation
        - [ ] Auth/authz
        - [ ] No secrets in code
        - [ ] Dependencies checked

  deliver: {}
  triage: {}
  diagnose: {}
  plan: {}
  integrate: {}
  deploy: {}
  monitor: {}
  optimize: {}

# State+Phase combos
combos:
  working+explore:
    enter: Explore thoroughly. Attach notes as you learn.

  working+implement:
    enter: |
      Execute with full context. Follow patterns, test alongside code, atomic commits.

      - **Before large refactorings** (touching 3+ files): search for ALL symbols/references first using find_referencing_symbols or grep, mark_file() ALL files you'll modify, then write a plan attachment before coding

  working+review:
    enter: Self-review mode. Check bugs, edge cases, test coverage.

# Gates (warn = self-discipline reminders, use force=true with reason to skip)
gates:
  status:working:
    - type: "gate/tests"
      enforcement: warn
      description: "Attach test results or explain why tests don't apply"
    - type: "gate/commit"
      enforcement: warn
      description: "Attach commit hash or note why no commit needed"
    - type: "gate/build"
      enforcement: warn
      description: "Run cargo check (or equivalent build verification) before marking tasks complete"

# Attachment types (document for future context)
attachments:
  recommended:
    note: Observations, decisions, reasoning (appends)
    plan: Approach and design (markdown, replaces)
    result: Outcome data (JSON, replaces)
    context: Resume state (replaces)
  documentation:
    log: Chronological actions (appends)
    diff: Code changes (appends)
    commit: Git hash reference (appends)
  debugging:
    error: Failures/blockers (appends)
    output: Command output (appends)
  metadata:
    meta: Structured metadata (JSON, replaces)
