# SOLO WORKFLOW - Single agent, coarse-grained tasks
# Use for: individual work, prototyping, personal task management

name: solo
description: Single agent working alone with coarse-grained, independent tasks

settings:
  initial_state: pending
  disconnect_state: pending
  blocking_states: [pending, assigned, working]
  unknown_phase: warn

states:
  pending:
    exits: [working, cancelled]
    timed: false
    prompts:
      enter: "Task available. Review and begin when ready."

  working:
    exits: [completed, failed, pending, consult]
    timed: true
    prompts:
      enter: |
        **Solo working.** Focus deeply. Attach notes for context continuity.

        - Progress phases via `update(phase="...")`
        - Self-review before completing
        - Attach results for your future self
        - Never revert unfamiliar changes: check `mark_updates()` / `list_marks()` first
        - `list_marks()` before editing for conflicts
        - 5+ files? Decompose into subtasks first
        - `thinking()` periodically for heartbeat (5+ min stale = eviction)

        Transitions: {{valid_exits}}
        Phase: {{current_phase}} | Valid: {{valid_phases}}

      exit: "Attach summary, note follow-ups, `log_metrics()`."

  completed:
    exits: [pending]
    timed: false
    prompts:
      enter: "Done. Results attached? Follow-up tasks needed?"

  failed:
    exits: [pending]
    timed: false
    prompts:
      enter: |
        Blocked. **Recovery procedure:**

        1. **Preserve progress:** `attach(type="error", content="...")` with what was attempted and what blocked
        2. **Clean up resources:**
           - `unmark_file()` all held files so they are available on retry
           - Release any held locks: `update(task="_lock:git-commit", status="pending")` if applicable
        3. **Classify and decide:**
           - *Transient* (build flake, network issue): set back to `pending` and retry immediately
           - *Missing info*: move to `consult` with a specific question for the human
           - *Wrong approach*: stay `failed`, attach what you learned, create a new task with revised approach
           - *Dependency*: `link(type="blocks", from="blocking-task")` and note what must resolve first
        4. **Context for future self:** attach enough detail that you (or another session) can resume
           without re-reading the entire codebase -- include file paths, function names, partial progress

  consult:
    exits: [working, pending, cancelled]
    timed: false
    prompts:
      enter: |
        **Paused for human review.** Before pausing:
        1. `unmark_file()` all held files so they are available if you resume in a new session
        2. Release any locks: `update(task="_lock:git-commit", status="pending")` if held
        3. `attach(type="note", content="...")` explaining:
           - What specific decision or input is needed
           - What you have completed so far and what remains
           - Enough context to resume without re-reading everything
        4. A human must transition this back to `working` or `pending`

  cancelled:
    exits: []
    timed: false

# Phase prompts
phases:
  explore:
    prompts:
      enter: "**Explore.** Read code/docs, understand patterns, identify constraints. Attach findings."
      exit: "Attach exploration summary."

  design:
    prompts:
      enter: "**Design.** Outline solution, consider alternatives, identify risks."
      exit: "Ensure design documented, alternatives noted, edge cases identified."

  implement:
    prompts:
      enter: "**Implement.** Follow patterns, write tests, small commits, `mark_file` first."
      exit: "Ensure compiles, tests pass, commit attached."

  test:
    prompts:
      enter: "**Test.** Run existing tests, add new ones, cover edge cases."
      exit: "Ensure all pass, results attached, edges covered."

  review:
    prompts:
      enter: "**Self-review:** code matches design? Edge cases? Tests comprehensive? Docs updated?"
      exit: "Ensure findings documented, blocking issues resolved."

  doc:
    prompts:
      enter: "**Document.** README, comments, API docs, examples as needed."
      exit: "Ensure doc changes committed, examples tested."

  security:
    prompts:
      enter: "**Security:** input validation, auth/authz, no secrets, deps checked."
      exit: "Ensure findings attached, critical issues flagged."

  triage:
    prompts:
      enter: "**Triage.** Categorize (bug/feature/refactor/chore), prioritize, assess scope. Set tags and priority."
      exit: "Ensure tags/priority set, description has 'why', scope assessed."

  plan:
    prompts:
      enter: "**Plan.** Outline approach, identify files/symbols, note risks. Attach plan note."
      exit: "Ensure plan attached, subtasks created if needed."

  diagnose:
    prompts:
      enter: "**Diagnose.** Reproduce, check logs/errors, narrow to module/function. Attach findings."
      exit: "Ensure root cause identified, fix approach outlined."

  integrate:
    prompts:
      enter: "**Integrate.** Full test suite. Check conflicts via `mark_updates()`. Verify no regressions."

  deliver:
    prompts:
      enter: "**Deliver.** All tests pass, version bumps, release notes, docs current."
      exit: "Ensure tests green, docs updated, commits clear."

  deploy:
    prompts:
      enter: "**Deploy.** `cargo check`, `cargo build --release`. Tag if applicable. Monitor post-deploy."
      exit: "Ensure build succeeded, deployment verified."

  monitor:
    prompts:
      enter: "**Monitor.** Check errors, performance, logs. Time-box. Attach observations."

  optimize:
    prompts:
      enter: "**Optimize.** Measure baseline, change one thing, re-measure. Keep only improvements."
      exit: "Ensure baseline/improvement metrics attached, no regressions."

# State+Phase combos
combos:
  working+explore:
    enter: "Explore thoroughly. Attach notes as you learn."

  working+implement:
    enter: |
      Execute with full context. Follow patterns, test alongside, atomic commits.
      - **3+ files**: search ALL symbols first, mark_file() ALL, plan attachment before coding

  working+review:
    enter: "Self-review: bugs, edge cases, test coverage."

  working+test:
    enter: "Full test suite. Add missing tests. Attach results."

  working+triage:
    enter: "Categorize, prioritize, assess scope. Set tags/priority before plan or implement."

  working+diagnose:
    enter: "Reproduce, narrow root cause, document findings. Then implement phase."

  working+design:
    enter: "Document approach, alternatives, risks. Attach design note before implementing."

  working+plan:
    enter: "Break down work. Create subtasks if complex. Identify unknowns. Attach plan."

  working+security:
    enter: "Systematic: inputs, auth, secrets, deps. Attach findings."

  working+deploy:
    enter: "Build, tag, ship. Monitor post-deploy. Note rollback plan."

  failed+implement:
    enter: |
      Implementation failed. Before leaving:
      - `unmark_file()` all held files
      - `attach(type="error")` with: files modified, build/test errors, partial progress
      - If partially committed: note the commit hash so you can resume or revert
      - Attach enough context to resume in a new session without re-exploring

  failed+deploy:
    enter: |
      Deployment failed. Document: what step failed, rollback status, whether partial deploy occurred.
      If rolled back: note the rollback commit. If stuck: move to `consult` with specific recovery question.

  working+optimize:
    enter: "Measure baseline. One change at a time. Measure after. Keep only what helps."

# Gates (self-discipline reminders)
gates:
  status:working:
    - type: "gate/tests"
      enforcement: warn
      description: "Attach test results or explain why tests don't apply"
    - type: "gate/commit"
      enforcement: warn
      description: "Attach commit hash or note why no commit needed"
    - type: "gate/build"
      enforcement: warn
      description: "Run cargo check before completing"

# Attachment types
attachments:
  recommended:
    note: Observations, decisions, reasoning (appends)
    plan: Approach and design (markdown, replaces)
    result: Outcome data (JSON, replaces)
    context: Resume state (replaces)
  documentation:
    log: Chronological actions (appends)
    diff: Code changes (appends)
    commit: Git hash reference (appends)
  debugging:
    error: Failures/blockers (appends)
    output: Command output (appends)
  metadata:
    meta: Structured metadata (JSON, replaces)
