# RELAY WORKFLOW - Sequential specialist handoffs, push coordination
# Flow: Designer -> Implementer -> Reviewer -> Tester
# Protocol: RECEIVE attachments -> PROCESS work -> DOCUMENT deliverables -> HANDOFF

name: relay
description: Specialists hand off work through phases like a relay race

# Extend base settings
settings:
  initial_state: pending
  disconnect_state: pending
  blocking_states: [pending, assigned, working]
  unknown_phase: warn

# Role definitions for specialists
roles:
  designer:
    description: Creates specifications and designs for features
    tags: [designer, design]
    phases: [design, explore]
    prompts:
      claim: |
        You are taking on a design task. Your deliverable is a clear specification.

        ## Design Deliverables
        - [ ] Clear problem statement
        - [ ] Proposed solution approach
        - [ ] Interface definitions (if applicable)
        - [ ] Edge cases identified
        - [ ] Acceptance criteria defined

        Attach your design document when complete for handoff to implementer.

      handoff: |
        Prepare handoff to implementer:
        - [ ] Design spec attached
        - [ ] Implementation notes added
        - [ ] Questions/blockers documented
        - [ ] Acceptance criteria explicit

  implementer:
    description: Implements features based on designs
    tags: [implementer, implement, code]
    phases: [implement, integrate]
    prompts:
      claim: |
        You are implementing a design. Review the design spec first.

        ## Implementation Checklist
        - [ ] Read and understand the design spec
        - [ ] Identify files to modify (use mark_file)
        - [ ] Follow existing patterns
        - [ ] Write unit tests alongside code
        - [ ] Document public APIs

        Ask the designer for clarification before guessing.

      handoff: |
        Prepare handoff to reviewer:
        - [ ] All code committed
        - [ ] Unit tests passing
        - [ ] Self-review completed
        - [ ] Implementation notes attached
        - [ ] Deviations from design documented

  reviewer:
    description: Reviews implementations for quality and correctness
    tags: [reviewer, review]
    phases: [review, security]
    prompts:
      claim: |
        You are reviewing an implementation. Focus on correctness and quality.

        ## Review Checklist
        - [ ] Read the original design spec
        - [ ] Review implementation against spec
        - [ ] Check test coverage
        - [ ] Look for edge cases
        - [ ] Verify error handling
        - [ ] Check for security issues

        Document findings before approval or rejection.

      handoff: |
        Prepare handoff to tester:
        - [ ] Review findings attached
        - [ ] Approval/rejection decision clear
        - [ ] If rejected: specific issues listed
        - [ ] If approved: test focus areas noted
        - [ ] Known limitations documented

  tester:
    description: Validates implementations through comprehensive testing
    tags: [tester, test, qa]
    phases: [test]
    prompts:
      claim: |
        You are testing an implementation. Verify it meets requirements.

        ## Testing Checklist
        - [ ] Read design spec and acceptance criteria
        - [ ] Review any review notes
        - [ ] Run existing test suite
        - [ ] Add integration tests if needed
        - [ ] Test edge cases
        - [ ] Verify error scenarios

        Document test results thoroughly.

      handoff: |
        Finalize testing:
        - [ ] Test results attached
        - [ ] Pass/fail determination clear
        - [ ] If failed: specific failures documented
        - [ ] If passed: coverage metrics noted
        - [ ] Recommended improvements listed (optional)

# State configuration with relay-specific prompts
states:
  pending:
    exits: [assigned, working, cancelled]
    timed: false

  assigned:
    exits: [working, pending, cancelled]
    timed: false
    prompts:
      enter: |
        A task has been assigned to you by the coordinator.

        ## Before Claiming
        - Review the task description
        - Check for prerequisite attachments
        - Verify you have the required expertise (check your role)

        Claim when ready with `claim()` or reject back to pending if misrouted.

  working:
    exits: [completed, failed, pending]
    timed: true
    prompts:
      enter: |
        You are now actively working on this task.

        ## Relay Protocol

        1. **Receive**: Read all attachments from previous specialist
        2. **Process**: Complete your phase's work
        3. **Document**: Attach your deliverables
        4. **Handoff**: Complete with clear notes for next specialist

        Keep your thinking updated regularly using the `thinking` tool.

        ### Heartbeat & Coordination
        - Call `thinking(agent=your_id, thought="...")` regularly to maintain heartbeat
        - Call `mark_updates(agent=your_id)` every 30-60s during long operations to check for handoff signals
        - Stale workers (no heartbeat for 5+ min) get evicted automatically

        ### Valid Transitions
        - `completed` - Phase complete, ready for handoff
        - `failed` - Blocked, needs coordinator intervention
        - `pending` - Release for reassignment

      exit: |
        Before completing:
        - [ ] Deliverables attached
        - [ ] Handoff notes clear
        - [ ] Files unmarked
        - [ ] Costs logged with `log_metrics()`

  completed:
    exits: [pending]
    timed: false
    prompts:
      enter: |
        Phase completed. Your deliverables should be attached.

        The coordinator will route this to the next specialist in the relay.

  failed:
    exits: [pending]
    timed: false
    prompts:
      enter: |
        Phase failed. Document clearly for coordinator:
        - What was attempted
        - What blocked progress
        - Whether to retry or escalate
        - Suggested next steps

  cancelled:
    exits: []
    timed: false

# Phase configuration for relay workflow
phases:
  design:
    prompts:
      enter: |
        ## Design Phase

        Create a specification that implementers can follow.

        **Inputs**: Requirements, context from explore phase
        **Outputs**: Design document with acceptance criteria

        Attach design doc before completing.

  implement:
    prompts:
      enter: |
        ## Implementation Phase

        Build what the design specifies.

        **Inputs**: Design specification
        **Outputs**: Working code with tests

        Mark files before editing. Ask designer if spec unclear.

  review:
    prompts:
      enter: |
        ## Review Phase

        Verify the implementation matches the design.

        **Inputs**: Design spec, implementation code
        **Outputs**: Review findings, approval/rejection

        Be specific about issues found.

  test:
    prompts:
      enter: |
        ## Test Phase

        Validate the implementation end-to-end.

        **Inputs**: Design spec, implementation, review notes
        **Outputs**: Test results, pass/fail determination

        Document failures with reproduction steps.

  explore:
    prompts:
      enter: |
        ## Explore Phase

        Investigate options before design.

        Attach findings for the designer.

  integrate:
    prompts:
      enter: |
        ## Integration Phase

        Merge work with the broader system.

        Coordinate with other implementers via mark_file.

  security:
    prompts:
      enter: |
        ## Security Review

        Check for vulnerabilities.

        - Input validation
        - Auth/authz
        - Secrets handling
        - Dependency risks

  # Phases without specific prompts
  deliver: {}
  triage: {}
  diagnose: {}
  plan: {}
  doc: {}
  deploy: {}
  monitor: {}
  optimize: {}

# State+Phase combos for relay
combos:
  working+design:
    enter: |
      Designing. Your deliverable is a spec the implementer can follow.
      Make acceptance criteria explicit and testable.

  working+implement:
    enter: |
      Implementing. Follow the design spec exactly.
      Ask the designer about unclear requirements before guessing.
      Write tests as you go.

  working+review:
    enter: |
      Reviewing. Check against the design spec.
      Be constructive - explain why something is an issue.
      Distinguish blocking issues from suggestions.

  working+test:
    enter: |
      Testing. Verify against acceptance criteria in the design.
      Document exact reproduction steps for failures.
      Note any untestable requirements.

  assigned+design:
    enter: |
      Design task assigned. Review the requirements and context.
      Check for any exploration findings to build on.

  assigned+implement:
    enter: |
      Implementation task assigned. The design spec should be attached.
      Read it fully before claiming.

  assigned+review:
    enter: |
      Review task assigned. Both design spec and implementation ready.
      Familiarize yourself with the scope before claiming.

  assigned+test:
    enter: |
      Test task assigned. Design, implementation, and review complete.
      Check for any known issues from review phase.

# Handoff protocol for relay transitions
handoff_protocol:
  description: |
    The relay workflow uses explicit handoffs between specialists.
    Each specialist completes their phase and hands off to the next.

  flow:
    - from: designer
      to: implementer
      via: design spec attachment
      notes: Include acceptance criteria, edge cases, interface definitions

    - from: implementer
      to: reviewer
      via: implementation + implementation notes
      notes: Document deviations from design, known limitations

    - from: reviewer
      to: tester
      via: review findings + approval
      notes: Highlight areas needing focus, known risks

    - from: tester
      to: coordinator
      via: test results
      notes: Pass/fail with evidence, improvement suggestions

  attachment_conventions:
    design_spec:
      type: design
      mime: text/markdown
      required_for: [implement, review, test]

    implementation_notes:
      type: impl-notes
      mime: text/markdown
      required_for: [review]

    review_findings:
      type: review
      mime: text/markdown
      required_for: [test]

    test_results:
      type: test-results
      mime: text/markdown
      required_for: []

# =============================================================================
# ATTACHMENT GUIDANCE
# =============================================================================
# Recommended attachment types for relay workflows. These types are pre-defined
# in config.yaml with appropriate MIME types and modes.
#
# Relay workflows depend heavily on attachments for handoff between specialists.
# Each phase produces artifacts that downstream specialists consume.

attachments:
  # Phase-specific deliverables (use these type names for handoff)
  phase_deliverables:
    plan:
      description: Design specification document (markdown, replaces)
      when: Designer phase completion - the primary handoff artifact
      example: |
        attach(task=id, type="plan", content="## Design Spec\n### Problem\n...\n### Solution\n...\n### Acceptance Criteria\n...")

    note:
      description: Phase observations and guidance for next specialist (appends)
      when: Each handoff - provide context the next specialist needs
      example: |
        # Designer -> Implementer
        attach(task=id, type="note", content="Edge case: handle empty input gracefully per AC #3")
        # Implementer -> Reviewer
        attach(task=id, type="note", content="Deviated from design in auth flow - see comment in code")

    result:
      description: Phase outcome summary (JSON, replaces)
      when: Phase completion - structured status for tracking
      example: |
        # Reviewer completion
        attach(task=id, type="result", content='{"verdict": "approved", "issues_found": 2, "issues_resolved": 2}')
        # Tester completion
        attach(task=id, type="result", content='{"passed": true, "tests_run": 15, "coverage": "92%"}')

  # Version control artifacts
  code_artifacts:
    commit:
      description: Git commit hash (appends)
      when: Implementer commits code, or after addressing review feedback
      example: |
        attach(task=id, type="commit", content="abc123f - Implement user auth per design spec")

    diff:
      description: Code changes for review (appends)
      when: Implementer -> Reviewer handoff, showing what changed
      example: |
        attach(task=id, type="diff", content="--- a/src/auth.rs\n+++ b/src/auth.rs\n...")

    changelist:
      description: Files modified in this phase (appends)
      when: Implementer completion - scope of changes
      example: |
        attach(task=id, type="changelist", content="src/auth.rs\nsrc/middleware.rs\ntests/auth_test.rs")

  # Quality and testing
  quality:
    error:
      description: Issues found during review or testing (appends)
      when: Reviewer finds bugs, Tester finds failures
      example: |
        # Reviewer
        attach(task=id, type="error", content="Missing null check in parse_input() - line 42")
        # Tester
        attach(task=id, type="error", content="Test failed: test_auth_timeout - expected 401, got 500")

    output:
      description: Test execution output (appends)
      when: Tester phase - raw test results
      example: |
        attach(task=id, type="output", content="Running auth tests...\n✓ test_login_success\n✓ test_login_failure\n...")

    log:
      description: Phase activity log (appends)
      when: Detailed audit trail for complex phases
      example: |
        attach(task=id, type="log", content="Review started 10:00\nFound issue #1 10:15\nDiscussed with impl 10:30\nResolved 10:45")

  # Metadata and tracking
  metadata:
    meta:
      description: Phase metrics and metadata (JSON, replaces)
      when: Tracking time, effort, or custom phase data
      example: |
        attach(task=id, type="meta", content='{"phase": "review", "duration_minutes": 45, "issues_found": 3}')

    context:
      description: Essential context that must not be lost (replaces)
      when: Critical information for downstream phases
      example: |
        attach(task=id, type="context", content="Auth uses JWT with 1h expiry - test must account for token refresh")

  # Workflow gates (if configured)
  gates:
    gate/tests:
      description: Evidence that tests pass
      when: Before transitioning past test gate
      example: |
        attach(task=id, type="gate/tests", content="All 42 tests passing as of commit abc123f")

    gate/review:
      description: Evidence of review approval
      when: Before transitioning past review gate
      example: |
        attach(task=id, type="gate/review", content="Approved by reviewer-agent after addressing 2 issues")

    gate/commit:
      description: Evidence of committed code
      when: Before transitioning past commit gate
      example: |
        attach(task=id, type="gate/commit", content="abc123f - merged to main")

# =============================================================================
# GATES
# =============================================================================
# Relay workflows use reject gates to ensure proper handoff artifacts.
# Each specialist must provide deliverables the next specialist needs.

gates:
  # Phase-exit gates enforce handoff artifacts
  phase:design:
    - type: "gate/spec"
      enforcement: reject
      description: "Design specification required for handoff to implementer"

  phase:implement:
    - type: "gate/commit"
      enforcement: reject
      description: "Commit hash required for reviewer"
    - type: "gate/impl-notes"
      enforcement: warn
      description: "Implementation notes explaining decisions"

  phase:review:
    - type: "gate/approval"
      enforcement: reject
      description: "Explicit approval or rejection with notes required"

  phase:test:
    - type: "gate/test-results"
      enforcement: reject
      description: "Comprehensive test results required"

# Task tree template for relay workflow
templates:
  feature:
    description: Standard feature development through relay phases
    tree:
      title: "{{feature_name}}"
      children:
        - title: "Design: {{feature_name}}"
          needed_tags: [designer]
          tags: [design]
        - title: "Implement: {{feature_name}}"
          needed_tags: [implementer]
          tags: [implement]
        - title: "Review: {{feature_name}}"
          needed_tags: [reviewer]
          tags: [review]
        - title: "Test: {{feature_name}}"
          needed_tags: [tester]
          tags: [test]
    sibling_type: follows  # Sequential dependencies

  bugfix:
    description: Bug fix through abbreviated relay
    tree:
      title: "Fix: {{bug_description}}"
      children:
        - title: "Diagnose: {{bug_description}}"
          needed_tags: [implementer]
          tags: [diagnose]
        - title: "Fix: {{bug_description}}"
          needed_tags: [implementer]
          tags: [implement]
        - title: "Verify: {{bug_description}}"
          needed_tags: [tester]
          tags: [test]
    sibling_type: follows
