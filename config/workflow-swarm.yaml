# SWARM WORKFLOW - Parallel generalists, fine-grained atomic tasks, pull coordination
# Use for: many independent tasks, max throughput, pre-decomposed work

name: swarm
description: Parallel generalists with fine-grained tasks for maximum throughput

settings:
  initial_state: pending
  disconnect_state: pending
  blocking_states: [pending, assigned, working]
  unknown_phase: warn

states:
  pending:
    exits: [assigned, working, cancelled]
    timed: false

  assigned:
    exits: [working, pending, cancelled]
    timed: false
    prompts:
      enter: "Task assigned. Review and claim when ready."

  working:
    exits: [completed, failed, pending, consult]
    timed: true
    prompts:
      enter: |
        **Swarm working.** Atomic tasks - work fast, release fast. ONE task at a time.

        **File coordination:** `mark_updates()` -> `mark_file()` -> edit -> `unmark_file()`
        - Never revert unfamiliar changes: check `mark_updates()` / `list_marks()` first
        - `list_marks()` before editing; if conflicts, coordinate or pick different task
        - 5+ files? Decompose into subtasks first
        - `thinking()` frequently for heartbeat + visibility
        - `mark_updates()` every 30-60s (critical in swarm - multiple agents target same files)
        - Stale workers (5+ min no heartbeat) get evicted
        - **Git lock**: `claim(task="_lock:git-commit")` -> commit -> release via `update(task="_lock:git-commit", status="pending")`

        Transitions: {{valid_exits}}
        Phase: {{current_phase}} (optional) | Valid: {{valid_phases}}

      exit: "`unmark_file()` all files, attach results, `log_metrics()`."

  completed:
    exits: [pending]
    timed: false
    prompts:
      enter: "Done. `list_tasks(ready=true)` for next task."

  failed:
    exits: [pending]
    timed: false
    prompts:
      enter: "Blocked. Document: attempted, blocker. `link(type=\"blocks\")` if dep issue."

  consult:
    exits: [working, pending, cancelled]
    timed: false
    prompts:
      enter: "**Paused for human review.** Attach note explaining decision needed."

  cancelled:
    exits: []
    timed: false

phases:
  explore:
    prompts:
      enter: "Quick exploration. Time-box. Attach findings."
      exit: "Attach findings immediately. Deep dives = follow-up tasks."

  implement:
    prompts:
      enter: "**Implement.** `mark_updates()` first. Small, focused changes."
      exit: "`unmark_file()`, commit attached, build verified."

  review:
    prompts:
      enter: "Quick review. Core works? No regressions? Detailed = separate task."
      exit: "Attach verdict. Detailed findings = separate task."

  test:
    prompts:
      enter: "Atomic testing matching atomic implementation."
      exit: "Attach test results."

  triage:
    prompts:
      enter: "**Triage.** Quick categorization: tags, priority, scope. No deep-dive."

  diagnose:
    prompts:
      enter: "**Diagnose.** Find root cause fast. Attach findings. Don't fix - create implement task."

  design:
    prompts:
      enter: "**Design.** Quick design note. Just enough for another agent to implement."

  plan:
    prompts:
      enter: "**Plan.** Decompose if complex. Many small tasks > one large task."

  security:
    prompts:
      enter: "**Security.** Quick check: input validation, no secrets, safe deps."

  doc:
    prompts:
      enter: "**Doc.** Update docs to match implementation. Brief and accurate."

  integrate:
    prompts:
      enter: "**Integrate.** No conflicts with parallel work. Full test suite."

  deliver:
    prompts:
      enter: "**Deliver.** Package for release. All tests, changelog."

  deploy:
    prompts:
      enter: "**Deploy.** Build, deploy, monitor for immediate issues."

  monitor:
    prompts:
      enter: "**Monitor.** Watch for issues. Time-box. Attach observations."

  optimize:
    prompts:
      enter: "**Optimize.** Measure before/after. One change at a time."

# State+Phase combos
combos:
  working+implement:
    enter: |
      Swarm impl: `mark_updates()` -> `mark_file()` -> edit fast -> `unmark_file()`. Keep `thinking()` updated.
      - **3+ files**: search ALL symbols first, mark_file() ALL, plan attachment before coding
      - **Git lock**: `claim(task="_lock:git-commit")` -> commit -> release

  working+explore:
    enter: "Time-boxed recon. Attach findings immediately. Deep dives = follow-up tasks."

  working+review:
    enter: "Quick review. Core correctness. Flag regressions. Detailed = separate tasks."

  working+test:
    enter: "Atomic test matching implementation scope. Attach results."

  working+triage:
    enter: "Quick triage: tag, prioritize, scope. Create subtasks if needed."

  working+diagnose:
    enter: "Fast diagnosis: reproduce, narrow, attach findings. Create implement task for fix."

  working+security:
    enter: "Quick security scan: input validation, no secrets, safe deps. Attach findings."

# Swarm roles (all agents are generalists)
roles:
  swarm_agent:
    description: Generalist agent working in parallel with peers
    tags: [worker, implementer, code]
    max_claims: 2
    can_assign: false
    can_create_subtasks: true

# Role prompts
role_prompts:
  swarm_agent:
    claim_guidance: |
      `list_tasks(ready=true)` -> pick ONE -> `claim()` -> work fast -> complete -> repeat.
      Throughput = fast cycles. Don't hoard tasks.

    file_coordination: |
      Check: `mark_updates()`, `list_marks(files=[...])`.
      Signal: `mark_file(file=path, reason="...")`.
      Conflict? Wait, coordinate, or split. Release: `unmark_file()`.
      **Always mark BEFORE editing.** Critical in swarm.

    visibility: |
      `thinking()` frequently. Your heartbeat is your only signal.
      Silent agents get evicted and tasks returned to pool.

# Gates (minimal for throughput)
gates:
  status:working:
    - type: "gate/summary"
      enforcement: allow
      description: "Brief summary for other agents (advisory)"
    - type: "gate/build"
      enforcement: warn
      description: "Run cargo check before completing"

# Attachment types
attachments:
  recommended:
    result: Completion data (JSON)
    note: Brief context for others
    error: Failures encountered
    commit: Git hash
  coordination:
    context: Info for next agent (replaces)
    output: Command output to preserve
  discouraged: [plan, diff, log]  # Too heavyweight for atomic tasks
