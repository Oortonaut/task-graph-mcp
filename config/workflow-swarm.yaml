# SWARM WORKFLOW - Parallel generalists, fine-grained atomic tasks, pull coordination
# Use for: many independent tasks, max throughput, pre-decomposed work
# Coordination: claim tasks, mark files, broadcast thinking

name: swarm
description: Parallel generalists with fine-grained tasks for maximum throughput

settings:
  initial_state: pending
  disconnect_state: pending
  blocking_states: [pending, assigned, working]
  unknown_phase: warn

states:
  pending:
    exits: [assigned, working, cancelled]
    timed: false

  assigned:
    exits: [working, pending, cancelled]
    timed: false
    prompts:
      enter: Task assigned. Review and claim when ready.

  working:
    exits: [completed, failed, pending, consult]
    timed: true
    prompts:
      enter: |
        **Swarm working.** Tasks are atomic - work fast, release fast.

        **File coordination:**
        1. `mark_updates()` - check recent activity
        2. `mark_file()` - signal intent before editing
        3. Wait/coordinate if conflicts

        **Discipline:** ONE task at a time. `thinking()` updates for visibility.

        - **Never revert unfamiliar changes**: if you find unexpected modifications in a file, do NOT revert them. Another worker may have made those changes. Use `mark_updates()` or `list_marks()` to check, and coordinate before overwriting
        - **Before editing**: call list_marks() to check if other workers have marked the same files. If conflicts found, coordinate or pick a different task
        - **Estimate scope first**: if a task touches 5+ files or requires broad symbol renaming, decompose into subtasks before starting. Three focused subtasks are better than one sprawling change

        ### Heartbeat & Coordination
        - Call `thinking(agent=your_id, thought="...")` regularly to maintain heartbeat
        - Call `mark_updates(agent=your_id)` every 30-60s during long operations to detect file conflicts
        - Stale workers (no heartbeat for 5+ min) get evicted automatically
        - In a swarm, frequent polling is critical -- multiple agents may target the same files

        Transitions: {{valid_exits}}
        Phase: {{current_phase}} (optional) | Valid: {{valid_phases}}

      exit: |
        Before completing:
        - [ ] `unmark_file()` any marked files
        - [ ] Attach results
        - [ ] `log_metrics()`

  completed:
    exits: [pending]
    timed: false
    prompts:
      enter: Done. `list_tasks(ready=true)` for next task. Attach results for others.

  failed:
    exits: [pending]
    timed: false
    prompts:
      enter: |
        Blocked. Document: attempted, blocker. Use `link(type="blocks")` if dependency issue. Release for others.

  consult:
    exits: [working, pending, cancelled]
    timed: false
    prompts:
      enter: |
        **Paused for human review.** Attach a note explaining what decision is needed.
        A human must transition this back to `working` or `pending`.

  cancelled:
    exits: []
    timed: false

phases:
  explore:
    prompts:
      enter: Quick exploration. Time-box it. Attach findings.

  implement:
    prompts:
      enter: |
        **Implement.** Check `mark_updates()` first. Small, focused changes.

  review:
    prompts:
      enter: Quick review. Core works? No regressions? Detailed review = separate task.

  test:
    prompts:
      enter: Atomic testing, matching atomic implementation.

  security: {}
  deliver: {}
  triage: {}
  diagnose: {}
  design: {}
  plan: {}
  doc: {}
  integrate: {}
  deploy: {}
  monitor: {}
  optimize: {}

# State+Phase combos
combos:
  working+implement:
    enter: |
      Swarm impl: `mark_updates()` -> `mark_file()` -> edit fast -> `unmark_file()`. Keep `thinking()` updated.

      - **Before large refactorings** (touching 3+ files): search for ALL symbols/references first using find_referencing_symbols or grep, mark_file() ALL files you'll modify, then write a plan attachment before coding

  working+explore:
    enter: Time-boxed recon. Attach findings immediately. Deep dives = follow-up tasks.

# Swarm reference (loaded on demand)
swarm_prompts:
  claim_guidance: |
    `list_tasks(ready=true)` -> pick ONE -> `claim()` -> work fast -> complete -> repeat.
    Throughput = fast cycles.

  file_coordination: |
    Check: `mark_updates()`, `list_marks(files=[...])`.
    Signal: `mark_file(file=path, reason="...")`.
    Conflict? Wait, coordinate, or split work.
    Release: `unmark_file()`.

  visibility: |
    `thinking()` frequently. Others monitor to avoid conflicts and coordinate.

# Gates (minimal for throughput - advisory/warn only)
gates:
  status:working:
    - type: "gate/summary"
      enforcement: allow
      description: "Brief summary for other agents (advisory)"
    - type: "gate/build"
      enforcement: warn
      description: "Run cargo check (or equivalent build verification) before marking tasks complete"

# Attachment types (brief, actionable)
attachments:
  recommended:
    result: Completion data (JSON)
    note: Brief context for others
    error: Failures encountered
    commit: Git hash
  coordination:
    context: Info for next agent (replaces)
    output: Command output to preserve
  discouraged: [plan, diff, log]  # Too heavyweight for atomic tasks
