# SWARM WORKFLOW - Parallel generalists, fine-grained atomic tasks, pull coordination
# Use for: many independent tasks, max throughput, pre-decomposed work
# Coordination: claim tasks, mark files, broadcast thinking

name: swarm
description: Parallel generalists with fine-grained tasks for maximum throughput

settings:
  initial_state: pending
  disconnect_state: pending
  blocking_states: [pending, assigned, working]
  unknown_phase: warn

states:
  pending:
    exits: [assigned, working, cancelled]
    timed: false

  assigned:
    exits: [working, pending, cancelled]
    timed: false
    prompts:
      enter: Task assigned. Review and claim when ready.

  working:
    exits: [completed, failed, pending]
    timed: true
    prompts:
      enter: |
        **Swarm working.** Tasks are atomic - work fast, release fast.

        **File coordination:**
        1. `mark_updates()` - check recent activity
        2. `mark_file()` - signal intent before editing
        3. Wait/coordinate if conflicts

        **Discipline:** ONE task at a time. `thinking()` updates for visibility.

        Transitions: {{valid_exits}}
        Phase: {{current_phase}} (optional) | Valid: {{valid_phases}}

      exit: |
        Before completing:
        - [ ] `unmark_file()` any marked files
        - [ ] Attach results
        - [ ] `log_metrics()`

  completed:
    exits: [pending]
    timed: false
    prompts:
      enter: Done. `list_tasks(ready=true)` for next task. Attach results for others.

  failed:
    exits: [pending]
    timed: false
    prompts:
      enter: |
        Blocked. Document: attempted, blocker. Use `link(type="blocks")` if dependency issue. Release for others.

  cancelled:
    exits: []
    timed: false

phases:
  explore:
    prompts:
      enter: Quick exploration. Time-box it. Attach findings.

  implement:
    prompts:
      enter: |
        **Implement.** Check `mark_updates()` first. Small, focused changes.

  review:
    prompts:
      enter: Quick review. Core works? No regressions? Detailed review = separate task.

  test:
    prompts:
      enter: Atomic testing, matching atomic implementation.

  security: {}
  deliver: {}
  triage: {}
  diagnose: {}
  design: {}
  plan: {}
  doc: {}
  integrate: {}
  deploy: {}
  monitor: {}
  optimize: {}

# State+Phase combos
combos:
  working+implement:
    enter: |
      Swarm impl: `mark_updates()` -> `mark_file()` -> edit fast -> `unmark_file()`. Keep `thinking()` updated.

  working+explore:
    enter: Time-boxed recon. Attach findings immediately. Deep dives = follow-up tasks.

# Swarm reference (loaded on demand)
swarm_prompts:
  claim_guidance: |
    `list_tasks(ready=true)` -> pick ONE -> `claim()` -> work fast -> complete -> repeat.
    Throughput = fast cycles.

  file_coordination: |
    Check: `mark_updates()`, `list_marks(files=[...])`.
    Signal: `mark_file(file=path, reason="...")`.
    Conflict? Wait, coordinate, or split work.
    Release: `unmark_file()`.

  visibility: |
    `thinking()` frequently. Others monitor to avoid conflicts and coordinate.

# Gates (minimal for throughput - advisory/warn only)
gates:
  status:working:
    - type: "gate/summary"
      enforcement: allow
      description: "Brief summary for other agents (advisory)"

# Attachment types (brief, actionable)
attachments:
  recommended:
    result: Completion data (JSON)
    note: Brief context for others
    error: Failures encountered
    commit: Git hash
  coordination:
    context: Info for next agent (replaces)
    output: Command output to preserve
  discouraged: [plan, diff, log]  # Too heavyweight for atomic tasks
